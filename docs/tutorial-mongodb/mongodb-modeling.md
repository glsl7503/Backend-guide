---
sidebar_position: 4
---

# 데이터 모델링

MongoDB는 **스키마리스(Schema-less) 데이터베이스**이지만, 성능과 확장성을 최적화하기 위해 **데이터 모델링이 중요**합니다. 여기서는 **임베디드(Embedded) 모델**과 **참조(Reference) 모델**, 그리고 모델 최적화 전략을 다룹니다.

---

### 🔹 데이터 모델 설계 방식

#### 🏗️ **1. 임베디드(Embedded) 모델**

- **한 문서(Document) 안에 하위 데이터 포함**
- **장점**: 조회 시 조인(Join) 필요 없음 → 빠른 성능
- **단점**: 중복 데이터 증가 가능

**예시: 사용자 & 주소 정보 포함**

```json
{
  "_id": ObjectId("xxx"),
  "name": "Alice",
  "age": 25,
  "address": {
    "city": "Seoul",
    "zip": "12345"
  }
}
```

✔️ **사용 사례**: 데이터가 자주 함께 조회될 때 (예: 유저 프로필, 설정 정보)

---

#### 🔗 **2. 참조(Reference) 모델**

- **별도 컬렉션으로 분리 후 _id 값으로 연결**
- **장점**: 데이터 중복 최소화, 관계형 데이터베이스와 유사
- **단점**: 조회 시 `$lookup`(JOIN) 필요 → 성능 저하 가능

**예시: 사용자 & 주문 데이터 분리**

```json
// users 컬렉션
{
  "_id": ObjectId("user123"),
  "name": "Bob"
}
```

```json
// orders 컬렉션
{
  "_id": ObjectId("order789"),
  "user_id": ObjectId("user123"),
  "product": "Laptop",
  "price": 1200
}
```

✔️ **사용 사례**: 데이터 간 **1:N 관계**가 많을 때 (예: 사용자 & 주문 데이터)

---

### 🔹 컬렉션 설계 최적화

#### 📌 **1. 읽기 vs 쓰기 중심 모델 선택**

- **읽기(Read) 최적화** → 임베디드 모델 활용
- **쓰기(Write) 최적화** → 참조 모델 활용

#### 📌 **2. 데이터 중복을 적절히 허용**

- **읽기 성능**이 중요하면 중복 허용 (예: 캐싱 데이터)
- **데이터 정합성**이 중요하면 참조 모델 활용

#### 📌 **3. 샤딩(Sharding) 고려**

- 대용량 데이터를 처리할 경우 샤딩을 통해 **수평 확장**

---

### 🔹 데이터 모델 선택 기준

| **기준**         | **임베디드(Embedded)** | **참조(Reference)** |
|------------------|-----------------------|---------------------|
| **쿼리 속도**      | 빠름                  | 상대적으로 느림      |
| **데이터 중복**    | 많을 수 있음          | 적음                |
| **관계형 구조**    | 1:1, 1:N(작은 규모)   | 1:N, N:M(복잡한 관계) |
| **확장성**        | 덜 유연함             | 더 유연함            |

---

### ✅ 결론

- **자주 함께 조회되는 데이터** → **임베디드 모델**
- **중복을 피하고 관계를 유지할 데이터** → **참조 모델**
- **읽기 성능이 중요** → 임베디드 모델 & 인덱스 활용
- **대량 데이터 확장 필요** → 샤딩 고려
